package com.github.matei.sentinel.persistence;

import java.time.Instant;
import java.util.Optional;
import java.util.Set;

/**
 * Interface for managing persistent state across application runs.
 * <p>
 * The state manager is responsible for:
 * <ul>
 *   <li>Tracking the last time each repository was checked</li>
 *   <li>Storing processed event IDs to prevent duplicate reporting</li>
 *   <li>Persisting this state to durable storage (e.g., file, database)</li>
 * </ul>
 * </p>
 *
 * <h2>State Management Strategy</h2>
 * <ul>
 *   <li><b>First Run</b>: No state exists, so {@link #getLastCheckTime} returns empty.
 *       The tool will only report events that occur AFTER startup.</li>
 *   <li><b>Subsequent Runs</b>: State exists with a timestamp. The tool will report
 *       all events since that timestamp, catching up on missed events.</li>
 * </ul>
 *
 * <h2>Event ID Management</h2>
 * Event IDs are stored to detect duplicate events. To prevent unbounded growth:
 * <ul>
 *   <li>Implementations should limit the number of stored event IDs (e.g., 1000)</li>
 *   <li>When the limit is exceeded, the oldest IDs should be removed (FIFO)</li>
 *   <li>This is safe because events older than the polling interval won't be re-fetched</li>
 * </ul>
 *
 * <h2>Concurrency</h2>
 * Implementations are not required to be thread-safe. The application uses a
 * single-threaded model for polling and state updates.
 *
 * <h2>Usage Example</h2>
 * <pre>{@code
 * StateManager stateManager = new FileStateManager();
 *
 * // Check if this is the first run
 * Optional<Instant> lastCheck = stateManager.getLastCheckTime("owner/repo");
 * if (lastCheck.isEmpty()) {
 *     System.out.println("First run - will only report new events");
 * } else {
 *     System.out.println("Previous run at: " + lastCheck.get());
 * }
 *
 * // After processing events
 * stateManager.updateLastCheckTime("owner/repo", Instant.now());
 * stateManager.addProcessedEventId("owner/repo", "event-123");
 * stateManager.save();
 * }</pre>
 *
 * @see FileStateManager
 * @since 1.0
 */
public interface StateManager
{
    /**
     * Retrieves the last time a repository was checked for new events.
     * <p>
     * This timestamp is used to filter GitHub API results, fetching only
     * workflow runs updated after this time.
     * </p>
     *
     * @param repository the repository in format "owner/repo"
     * @return the last check timestamp wrapped in {@link Optional}, or {@link Optional#empty()}
     *         if the repository has never been checked (first run)
     * @throws IllegalArgumentException if repository is null or empty
     */
    Optional<Instant> getLastCheckTime(String repository);

    /**
     * Updates the last check time for a repository.
     * <p>
     * This method should be called after successfully processing events, typically
     * with the current timestamp. On the next run, the tool will fetch events
     * since this timestamp.
     * </p>
     *
     * <p><b>Note</b>: This method only updates in-memory state. Call {@link #save()}
     * to persist the change to durable storage.</p>
     *
     * @param repository the repository in format "owner/repo"
     * @param timestamp the new last check timestamp (typically {@link Instant#now()})
     * @throws IllegalArgumentException if repository is null/empty or timestamp is null
     */
    void updateLastCheckTime(String repository, Instant timestamp);

    /**
     * Retrieves the set of event IDs that have already been processed for a repository.
     * <p>
     * Event IDs are used to prevent duplicate reporting of the same event. An event
     * ID is typically generated by combining workflow run ID, job ID, step name, and
     * event type (e.g., "run-123-job-456-step-Build-completed").
     * </p>
     *
     * <p>The returned set is a defensive copy and can be safely modified by the caller.</p>
     *
     * @param repository the repository in format "owner/repo"
     * @return an immutable set of processed event IDs, may be empty but never {@code null}
     * @throws IllegalArgumentException if repository is null or empty
     */
    Set<String> getProcessedEventIds(String repository);

    /**
     * Adds an event ID to the set of processed events for a repository.
     * <p>
     * This method marks an event as "already reported" so it won't be reported again
     * on subsequent polls or runs.
     * </p>
     *
     * <p><b>Memory Management</b>: Implementations should limit the number of stored
     * event IDs to prevent unbounded growth. When the limit is exceeded, the oldest
     * IDs should be removed.</p>
     *
     * <p><b>Note</b>: This method only updates in-memory state. Call {@link #save()}
     * to persist the change to durable storage.</p>
     *
     * @param repository the repository in format "owner/repo"
     * @param eventId the unique identifier for the event
     * @throws IllegalArgumentException if repository or eventId is null or empty
     * @see #getProcessedEventIds(String)
     */
    void addProcessedEventId(String repository, String eventId);

    /**
     * Persists the current state to durable storage.
     * <p>
     * This method writes all in-memory state changes (last check times and processed
     * event IDs) to the underlying storage mechanism (e.g., file, database).
     * </p>
     *
     * <p><b>When to call</b>: Call this method after:</p>
     * <ul>
     *   <li>Updating the last check time with {@link #updateLastCheckTime}</li>
     *   <li>Adding processed event IDs with {@link #addProcessedEventId}</li>
     *   <li>Before application shutdown to ensure state is not lost</li>
     * </ul>
     *
     * <p><b>Error Handling</b>: If saving fails (e.g., disk full, permissions error),
     * implementations should log the error to stderr but not throw an exception. This
     * prevents a storage failure from crashing the monitoring process.</p>
     */
    void save();
}
